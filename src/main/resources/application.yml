nextflow:
  k8s:
    runAsUser: 9999
    namespace: "default" # Namespace where app will be running
    runNamespace: "default" # Namespace where wes and nf pods will live
    serviceAccount: "default"
    volMounts:
      - "pv-claim:/some/dir"
    masterUrl: "localhost:8080"
    trustCertificate: false
  weblogUrl: "http://localhost"
  monitor:
    sleepInterval: 1000 # milliseconds
    maxErrorLogLines: 50 # we put the last ${maxErrorLogLines} into the error message if a Pod fails

secret:
  enabled: false

---
spring.profiles: secure
auth:
  jwtPublicKeyUrl: ""
  jwtPublicKeyStr: "-----BEGIN PUBLIC KEY-----\nSET ME IF YOU DONT HAVE A URL, BUT URL TAKES PRIORITY\n-----END PUBLIC KEY-----"
  graphqlScopes:
    queryOnly:
      - RDPC-CA.READ
    queryAndMutation:
      - RDPC-CA.WRITE

---
spring.profiles: apiKey

secret:
  enabled: true
  apiKey: testapikeytotallylegit

---
spring.profiles: oauth2Token

secret:
  enabled: true
  clientId: testId
  clientSecret: testSecret
  tokenUri: http://localhost:8080/oauth/token

---
spring.profiles: initialized-to-start

spring.cloud.stream:
  function.definition: queudToStartConsumer
  bindings:
    queudToStartConsumer-in-0:
      group: mgmt-queue
      destination: wfmgmtevent # kafka topic to listen to
      binder: kafka

spring.cloud.stream.kafka:
  binder.brokers: localhost:9092
  bindings:
    queued-in-0:
      consumer:
        enableDlq: true
        dlqName: queued-in-0_dlq
        autoCommitOnError: true
        autoCommitOffset: true
#        resetOffsets: true
#        startOffset: earliest

---
spring.profiles: start-is-queued
